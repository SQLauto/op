-- =============================================
-- Author:		Sharon
-- Create date: 09/02/2015
-- Update date: 11/02/2015 @@SPID
--				06/12/2015 Sharon Add Columns
--				21/12/2015 Sharon 91875
-- Description:	Mode :: 
--				0 - GET Transaction IsolationLevel
--				1 - GET Percent Complete
-- =============================================
CREATE PROCEDURE [Server].[usp_GetSessionInfo]
    @HostName NVARCHAR(128) = NULL ,
    @OnlyApp bit = 1,
	@DatabaseName sysname,
	@Mode INT = 0 ,
	@TimeOn BIT = 0,
	@JobInfoOn BIT = 0 ,
	@OnlyRunnigProcessOn BIT = 0 ,
	@TimeFilter BIT = 0 ,
	@IncludeSystemDatabase BIT = 0 ,
	@IncludeAllUserDatabase BIT = 0 ,
	@ConsiderIgnorList BIT = 0,
	@FilterJob BIT = 0
	
AS
BEGIN
    SET NOCOUNT ON;
	DECLARE @SQLVer2012andUP BIT = 0
	--http://www.brentozar.com/archive/2015/05/sql-server-version-detection/
	CREATE TABLE #checkversion (
		version nvarchar(128),
		common_version AS SUBSTRING(version, 1, CHARINDEX('.', version) + 1 ),
		major AS PARSENAME(CONVERT(VARCHAR(32), version), 4),
		minor AS PARSENAME(CONVERT(VARCHAR(32), version), 3),
		build AS PARSENAME(CONVERT(varchar(32), version), 2),
		revision AS PARSENAME(CONVERT(VARCHAR(32), version), 1)
	);

	INSERT INTO #checkversion (version)
	SELECT CAST(SERVERPROPERTY('ProductVersion') AS NVARCHAR(128)) ;
	IF EXISTS(SELECT TOP 1 1 FROM #checkversion WHERE major >= 11)
		SET @SQLVer2012andUP = 1;
	DECLARE @IsKillAllow BIT = 0;
	DECLARE @DomainName sysname = 'OPENU';
	DECLARE @DateTaken datetime = GETDATE();
	----------------------------------------------------------------
	IF @ConsiderIgnorList = 1
	BEGIN
	    CREATE TABLE #IgnoreProgram (program_name VARCHAR(1000) NOT NULL);
		INSERT #IgnoreProgram
		        ( program_name )
		VALUES  ( '_Admin_ :: TrackBlocking'),
				('Update_Statistics'),
				('_Admin_ :: UpdateIndexStats')
		CREATE TABLE #IgnoreUsers (LoginName VARCHAR(1000) NOT NULL);
		--INSERT #IgnoreUsers
		--        ( LoginName )
		--SELECT	IIF(IL.IsSQLLogin = 0,SS.DomainName + '\' + IL.LoginName + '-svc',IL.LoginName) 
		--FROM	_Admin_.SessionInfo_IgnoreLogin IL
		--		INNER JOIN DBSetup.Security_Server SS ON SS.ID = IL.ServerID
		--WHERE	SS.ServerName = @@ServerName;

		SELECT	@IsKillAllow = 0
	END

	DECLARE @DBID INT;
	IF ISNULL(@Mode,0) IN (0,2)
	BEGIN
	DECLARE @sql NVARCHAR(max) = N'';
	DECLARE @KILL NVARCHAR(max) = N'';
	IF ISNULL(@Mode,0) = 0
		SELECT @sql += N'
SELECT  @DateTaken [DateTaken],' + CASE WHEN @TimeFilter = 1 OR @TimeOn = 1 THEN N'DTON.[dd hh:mm:ss.mss],' ELSE N'' END + N'
s.session_id
' + CASE WHEN @SQLVer2012andUP = 1 THEN N',DB_NAME(s.database_id)DatabaseName' ELSE N'' END + N'
,Coalesce(Quotename(Db_name(t.dbid)) + N''.'' + Quotename(
		   Object_schema_name(t.objectid,
					t.dbid)) +
					N''.'' + Quotename(Object_name(t.objectid, t.dbid)), '''') [StoredProcedure]
,host_name
,login_name
' + IIF(@TimeFilter = 0,',login_time','')	+ '
,' + CASE WHEN @JobInfoOn = 1 OR @ConsiderIgnorList = 1 THEN N'Program.program_name' ELSE N'program_name' END+ N'
,client_interface_name
,s.status
,r.wait_type 
,CASE s.transaction_isolation_level
          WHEN 0 THEN ''Unspecified''
          WHEN 1 THEN ''ReadUncomitted''
          WHEN 2 THEN ''Readcomitted''
          WHEN 3 THEN ''Repeatable''
          WHEN 4 THEN ''Serializable''
          WHEN 5 THEN ''Snapshot''
        END AS TRANSACTION_ISOLATION_LEVEL
' + IIF(@TimeFilter = 0,'
,tdt.database_transaction_begin_time
,CASE tdt.database_transaction_type
    WHEN 1 THEN ''Read/write transaction''
    WHEN 2 THEN ''Read only transaction''
    WHEN 3 THEN ''System transaction''
END TransactionType 
,CASE tdt.database_transaction_state
    WHEN 1 THEN ''Transaction not initialized''
    WHEN 3 THEN ''Transaction has not generated by any log''
    WHEN 4 THEN ''Transaction has generated by log''
    WHEN 5 THEN ''Transaction Prepared''
    WHEN 10 THEN ''Transaction Committed''
    WHEN 11 THEN ''Transaction Rolled back''
    WHEN 12 THEN ''Transaction committed and log generated''
END TransactionState
,s.Reads
,s.Writes','') + '
,r.Command
,t.Text
,''''  [KillThatMotherFuker]
' + IIF(@TimeFilter = 0,',r.Arithabort
,r.Ansi_Null_dflt_on
,r.Ansi_Defaults
,r.Ansi_Warnings
,r.Ansi_Padding
,r.Ansi_Nulls
,r.Concat_null_yields_null
,r.Deadlock_priority
,r.Lock_timeout','') 
	IF @Mode = 2 
		SELECT @sql += N'SET @KILL = '''';
SELECT @KILL += ''KILL '' + CONVERT(VARCHAR(5),s.session_id) + '';
'''
SELECT @sql +=
'
FROM    sys.dm_exec_sessions s
		INNER JOIN sys.dm_exec_requests r ON R.session_id = S.session_id
		LEFT JOIN sys.dm_tran_session_transactions tst ON tst.session_id = S.session_id
		LEFT JOIN sys.dm_tran_database_transactions tdt ON tst.transaction_id = tdt.transaction_id
			AND S.database_id = tdt.database_id
		CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
		LEFT JOIN SYS.databases D ON D.database_id = S.database_id
		OUTER APPLY (SELECT [dbo].[ufn_Util_clr_RegexReplace](login_name,''([\W\w]*)\\([\W\w0-9]*)'',''$1'',0) Domain)KILLU
		'
		SELECT @sql += CASE WHEN @TimeFilter = 1 OR @TimeOn = 1 THEN N'OUTER APPLY (SELECT COALESCE(
							CASE
								WHEN
								(
									s.is_user_process = 0
									AND r.total_elapsed_time >= 0
								) THEN
									DATEADD
									(
										ms,
										1000 * (DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())) / 500) - DATEPART(ms, DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())),
										DATEADD(second, -(r.total_elapsed_time / 1000), GETDATE())
									)
							END,
							NULLIF(COALESCE(r.start_time, r.start_time/*sp.last_request_end_time*/), CONVERT(DATETIME, ''19000101'', 112)),
							(
								SELECT TOP(1)
									DATEADD(second, -(ms_ticks / 1000), GETDATE())
								FROM sys.dm_os_sys_info
							)
						) AS start_time )Y

	OUTER APPLY (SELECT CASE
						WHEN DATEDIFF(day, y.start_time, GETDATE()) > 24 THEN
							DATEDIFF(second, GETDATE(), y.start_time)
						ELSE DATEDIFF(ms, y.start_time, GETDATE())
					END AS elapsed_time)N
	OUTER APPLY (SELECT CASE MAX(LEN(CONVERT (VARCHAR, CASE
                                                              WHEN N.elapsed_time < 0
                                                              THEN ( -1
                                                              * N.elapsed_time )
                                                              / 86400
                                                              ELSE N.elapsed_time
                                                              / 86400000
                                                              END))) OVER ( )
                                  WHEN 1 THEN 2
                                  ELSE MAX(LEN(CONVERT (VARCHAR, CASE
                                                              WHEN N.elapsed_time < 0
                                                              THEN ( -1
                                                              * N.elapsed_time )
                                                              / 86400
                                                              ELSE N.elapsed_time
                                                              / 86400000
                                                              END))) OVER ( )
                                END AS max_elapsed_length)X
		CROSS APPLY (SELECT CASE WHEN elapsed_time < 0
                         THEN RIGHT(REPLICATE(''0'', max_elapsed_length)
                                    + CONVERT(VARCHAR, ( -1 * elapsed_time )
                                    / 86400), max_elapsed_length)
                              + RIGHT(CONVERT(VARCHAR, DATEADD(SECOND,
                                                              ( -1
                                                              * elapsed_time ),
                                                              0), 120), 9)
                              + ''.000''
                         ELSE RIGHT(REPLICATE(''0'', max_elapsed_length)
                                    + CONVERT(VARCHAR, elapsed_time / 86400000),
                                    max_elapsed_length)
                              + RIGHT(CONVERT(VARCHAR, DATEADD(SECOND,
                                                              elapsed_time
                                                              / 1000, 0), 120),
                                      9) + ''.'' + RIGHT(''000''
                                                       + CONVERT(VARCHAR, elapsed_time
                                                       % 1000), 3)
                    END AS [dd hh:mm:ss.mss])DTON' ELSE N'' END 
SELECT @sql += CASE WHEN @JobInfoOn = 1 OR @ConsiderIgnorList = 1 THEN N'
	LEFT JOIN (SELECT  j.name AS JobName ,
			ja.Start_execution_date StartExecutionDate,
			ISNULL(last_executed_step_id, 0) + 1 AS CurrentExecutedStepID ,
			js.step_name StepName,
			CONCAT(joa.Duration,'' Min'') Duration,
			SUBSTRING(JAjid.job_id,7,2) +
    SUBSTRING(JAjid.job_id,5,2) +
    SUBSTRING(JAjid.job_id,3,2) +
    SUBSTRING(JAjid.job_id,1,2) +
    SUBSTRING(JAjid.job_id,12,2) +
    SUBSTRING(JAjid.job_id,10,2) +
    SUBSTRING(JAjid.job_id,17,2) +
    SUBSTRING(JAjid.job_id,15,2) +
    SUBSTRING(JAjid.job_id,20,4) +
    SUBSTRING(JAjid.job_id,25,12) JobIDSt
	FROM    msdb.dbo.sysjobactivity ja
			CROSS APPLY (SELECT TOP 1 CAST(jA.job_id AS VARCHAR(50)) AS job_id)JAjid
			LEFT JOIN msdb.dbo.sysjobhistory jh ON ja.job_history_id = jh.instance_id
			INNER JOIN msdb.dbo.sysjobs j ON ja.job_id = j.job_id
			INNER JOIN msdb.dbo.sysjobsteps js ON ja.job_id = js.job_id
											AND ISNULL(ja.last_executed_step_id, 0)
											+ 1 = js.step_id
			OUTER APPLY ( SELECT  DATEDIFF(MINUTE,ja.start_execution_date,GETDATE()) Duration ) joa
	WHERE   ja.session_id = ( SELECT TOP 1
										session_id
							  FROM      msdb.dbo.syssessions
							  ORDER BY  agent_start_date DESC
							)
			AND start_execution_date IS NOT NULL
			AND stop_execution_date IS NULL)JOB ON JOB.JobIDSt = SUBSTRING(S.program_name,CHARINDEX(''0x'',s.program_name)+2,32)
	CROSS APPLY (SELECT IIF(job.JobName IS NULL,program_name,''Job:: ''+ job.JobName + ''('' + job.Duration +'')'') program_name,
						IIF(job.JobName IS NULL,program_name,job.JobName) ProgramFilterName)Program' ELSE N'' END 
SELECT @sql +=
'
		
WHERE	s.session_id > 50
		AND s.session_id != @@SPID
		AND S.database_id != DB_ID(''UNIT'')'
		IF @HostName IS NOT NULL SELECT @sql+= N'
		AND S.host_name = '''+@HostName+''' ';
		IF @OnlyApp = 1 SELECT @sql+= N'
		AND S.program_name NOT IN (''dbForge SQL Complete Express'',''Microsoft SQL Server Management Studio'',''Microsoft SQL Server Management Studio - Query'',''Microsoft SQL Server Management Studio - Transact-SQL IntelliSense'') ';
		IF @OnlyRunnigProcessOn = 1 SELECT @sql+= N'
		AND s.status = ''running'' ';
		IF @IncludeSystemDatabase = 0 SELECT @sql+= N'
		AND S.database_id > 4 ';
		IF @TimeFilter = 1 SELECT @sql+= N'
		AND DTON.[dd hh:mm:ss.mss] > ''00 00:00:30.000''';
		IF @ConsiderIgnorList = 1 SELECT @sql+= N'
		AND Program.ProgramFilterName NOT IN (SELECT [program_name] FROM #IgnoreProgram)
		AND login_name NOT IN (SELECT LoginName FROM #IgnoreUsers)
		AND ISNULL(Object_name(t.objectid, t.dbid),'''') NOT LIKE ''usp_SSIS%''';
		IF @FilterJob = 1 SELECT @sql+= N'
		AND S.program_name NOT LIKE ''%JOB%''';
		IF @SQLVer2012andUP = 1
		BEGIN
			IF @DatabaseName IS NOT NULL AND @IncludeAllUserDatabase = 0
			BEGIN
				SELECT @sql+= N'
		AND S.database_id = @DBID';
				SELECT @DBID = DB_ID(@DatabaseName);
			END
		END
		BEGIN TRY 
		
			EXEC sp_executesql @sql,N'@DateTaken datetime,@DBID INT, @KILL NVARCHAR(max) OUT', @DateTaken = @DateTaken ,@DBID = @DBID ,@KILL = @KILL OUTPUT
			--EXEC [dbo].[PrintMax] @sql;
			IF @Mode = 2
				EXEC [dbo].[PrintMax] @KILL
		END TRY
		BEGIN CATCH
			
			EXEC [dbo].[PrintMax] @sql;
			THROW;
		END CATCH
		
		
	END

	IF @Mode = 1
        SELECT  r.session_id ,
                r.command ,
                CONVERT(NUMERIC(6, 2), r.percent_complete) AS [Percent Complete] ,
                CONVERT(VARCHAR(20), DATEADD(ms, r.estimated_completion_time,
                                             GETDATE()), 20) AS [ETA Completion Time] ,
                CONVERT(NUMERIC(10, 2), r.total_elapsed_time / 1000.0 / 60.0) AS [Elapsed Min] ,
                CONVERT(NUMERIC(10, 2), r.estimated_completion_time / 1000.0
                / 60.0) AS [ETA Min] ,
                CONVERT(NUMERIC(10, 2), r.estimated_completion_time / 1000.0
                / 60.0 / 60.0) AS [ETA Hours] ,
                CONVERT(VARCHAR(1000), ( SELECT SUBSTRING(text,
                                                          r.statement_start_offset
                                                          / 2,
                                                          CASE
                                                              WHEN r.statement_end_offset = -1
                                                              THEN 1000
                                                              ELSE ( r.statement_end_offset
                                                              - r.statement_start_offset )
                                                              / 2
                                                          END)
                                         FROM   sys.dm_exec_sql_text(sql_handle)
                                       ))[text]
        FROM    sys.dm_exec_requests r
        WHERE   command IN ( 'RESTORE DATABASE', 'BACKUP DATABASE' );
END